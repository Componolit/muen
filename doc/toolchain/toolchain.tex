\documentclass[a4paper,twoside,titlepage]{article}
\usepackage[hmarginratio=1:1]{geometry}
\setcounter{secnumdepth}{3}
\usepackage{graphicx}
\usepackage{titlepic}
\usepackage[dvipsnames]{xcolor}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{positioning,shapes,shadows,arrows,fit,decorations.markings}
\usepackage{fancyhdr}
\pagestyle{fancy}
\usepackage[
	pdftitle={Muen},
	pdfsubject={Toolchain},
	pdfauthor={Reto Buerki, Adrian-Ken Rueegsegger},
	pdfkeywords={Separation Kernel, Toolchain, Build, System Image, XML},
	unicode=true,
	bookmarks=true,
	bookmarksnumbered=false,
	bookmarksopen=false,
	breaklinks=true,
	pdfborder={0 0 0},
	backref=false,
	colorlinks=false]{hyperref}

\lstset{
	basicstyle={\ttfamily\scriptsize},
	breakautoindent=true,
	breaklines=true,
	captionpos=b,
	extendedchars=true,
	frame=single,
	numbers=left,
	numberstyle={\tiny},
	showspaces=false,
	showstringspaces=false,
	tabsize=2,
	keywordstyle={\color{MidnightBlue}},
	commentstyle={\color{Aquamarine}},
	literate={~} {$\sim$}{1}
}

\title{Muen - Toolchain}
\author{Reto Buerki \and Adrian-Ken Rueegsegger}
\titlepic{\includegraphics[scale=0.4]{images/muen.pdf}}

\begin{document}
\input{tikzstyle}

\maketitle

\begin{center}
	University of Applied Sciences Rapperswil (HSR), Switzerland
\end{center}
\clearpage

\tableofcontents
\listoffigures
\lstlistoflistings

\section{Introduction}
This document describes the process of configuring and building a
component-based system running on the Muen separation kernel (SK).

\section{Policy}
A policy is a description of a component-based system running on top of the Muen
separation kernel. It specifies properties such as

\begin{itemize}
	\item Hardware platform
	\item Physical memory regions
	\item Device domains
	\item Events
	\item Communication channels
	\item Components
	\item Subjects
	\item Scheduling plans
\end{itemize}

\subsection{Content}
\subsubsection{Hardware Platform}

\subsubsection{Physical memory regions}
Part of the policy is the description of the available hardware resources of a
given target platform. Each hardware system specifies the available physical
memory, hardware devices and properties of the processor such as the logical
CPU count.

\subsubsection{Device Domains}
\subsubsection{Events}
\subsubsection{Communication Channels}
\subsubsection{Components}
\subsubsection{Subjects}
The system policy defines active execution environments in the form of
components and subjects. A subject specification assigns system resources such
as physical memory mappings, devices as well as inter-subject communication
channels and events.

\subsubsection{Scheduling Plans}

\subsection{Format}
The system policy is specified in XML.

TODO: Describe the general concept here. From permissive XML schema to more
restrictive ones etc. No implicit values at the end. Policy always reviewable
after each step.

\subsubsection{Source Format}
System policy defined by the user. Many attributes are optional. Constructs
like channels provide abstraction.

The user may not provide kernel, tau0 and platform configuration (enforced by
XSD).

\subsubsection{Format A}
Contains an expanded configuration containing all memory regions with given
size. Kernel and tau0 configuration is added.

Subject profiles are expanded to their respective values. The Expander may also
change values depending on the detected configuration.

\subsubsection{Format B}
Format B is equivalent to Format A except that the Allocator has assigned a
physical address to all elements of the memory layout.

\section{Build Process}
The build of a system is divided into the following steps:

\begin{itemize}
	\item Policy compilation
	\item Policy validation
	\item Structure generation
	\item Image packaging
\end{itemize}

The toolchain is composed of several tools that operate on a user-specified
system policy. Following the Unix philosophy "A program should do only one thing
and do it well" each of the tools performs a specific task. They work in
conjunction to process a user-defined policy and build a bootable system image.
An in-depth description of the involved tools is given in section
\ref{sec:tools} while figure \ref{fig:build-process} gives an overview of the
whole build process.

\begin{figure}[h]
	\centering
	\input{graph_build_process}
	\caption{Build process}
	\label{fig:build-process}
\end{figure}

\subsection{Policy Compilation}
Policy compilation encompasses the tasks involved to transform the policy from
source format to format A and finally to format B, which is the fully expanded
format with no implicit properties.

The Merger tool is responsible to merge all XML files referenced by the
user-specified system policy in format source. It is basically an implementation
of the XML XInclude mechanism\footnote{\url{http://www.w3.org/TR/xinclude-11/}}
with the additional benefit that the resulting policy is already well formatted
to minimize the difference in the generated policies resulting from the
following tasks.  This allows the user to easily review (\texttt{diff}) and
therefore verify the results of each policy compilation task.

Using the XInclude mechanism, the policy writer is able to separate and organize
the system policy as desired. Instead of specifying the whole policy in one
file, the subject specifications could be put in separate files, or if multiple
hardware platforms are supported, the parts common to all platforms could be
extracted as well. See section \ref{sec:tools-merger} for more information about
the Merger tool.

After the merge task, the Expander tool takes care of completing the
user-specified policy with additional information and abstractions only
available in format source are resolved to low-level mechanisms.

For example, the concept of \emph{channels} only exists in format source.
Therefore a channel specified in format source must be expanded to shared memory
regions with optional associated events in format A.  Also, the Expander tool
inserts specifications for the Muen kernel itself so the user is lifted from
that burden. Generally, the aim of the expansion task is to make the life of a
policy writer as easy as possible by expanding all information which can be
derived automatically. Section \ref{sec:tools-expander} explains the Expander
tool in detail.

The result of the expansion task is a policy in format A which is the input for
the Allocator tool. This tool is responsible to assign a physical memory address
to all memory regions which are not already explicitly stated. By querying the
platform section of the policy, the tool is aware of the total amount of
available RAM on a specific system and allocates regions of it for memory
elements with no explicit physical address.  The Allocator tools also implements
optimization strategies to keep the resulting system image as small as possible.
For example, file-backed memory regions (e.g. a memory region storing a
component executable) are preferably placed in lower physical regions. See
section \ref{sec:tools-allocator} for a description of the Allocator tool.

After the allocation task is complete, the policy is stored in format B. This
format states all system properties explicitly and is used as input for the
Validation step discussed in the following section.

\subsection{Policy Validation}
Before structures required to pack the final system image are generated, the
policy must be thoroughly validated to catch errors in the system specification.
Such errors might range from overlapping memory, undefined resource references
to incomplete scheduling plans etc. The Validator task performs checks that
assure the policy in format B is sound and contains no higher-level errors which
cannot be handled by XML schemata restrictions only.

It is important to always run the Validator as the system could behave
erroneously or crash otherwise. This is especially true if a policy writer
decides to specify the system directly in format B which is also possible of
course (but not advised).  Section \ref{sec:tools-validator} explains the
Validator tool and lists some example checks performed by the tool as
illustration.

\subsection{Structure Generation}
\subsection{Image Packaging}

\section{Tools}
\label{sec:tools}

\subsection{Merger}
\label{sec:tools-merger}
The Merger combines user-provided system policy files into a single XML
document.

\begin{description} \itemsep1pt \parskip0pt
	\item[Name] \hfill \\
		\texttt{mucfgmerge}
	\item[Input] \hfill \\
		Toplevel system policy, platform file
	\item[Output] \hfill \\
		System policy, merged
\end{description}

This tool merges the system policy and included files into a single file. It is
a replacement for the XInclude mechanism, which is not supported by the XML/Ada
library. XML Content is re-formatted so changes to the policy by subsequent
build steps (e.g. expander) can be manually reviewed or visualized by diffing
the files.

\subsection{Expander}
\label{sec:tools-expander}
The expander completes the user-provided system policy by creating or deriving
additional configuration elements.

\begin{description} \itemsep1pt \parskip0pt
	\item[Name] \hfill \\
		\texttt{mucfgexpand}
	\item[Input] \hfill \\
		Toplevel system policy, separate hardware and platform configuration
	\item[Output] \hfill \\
		System policy, expanded
	\item[Data] \hfill
		\begin{enumerate}
			\item Implicit kernel config (compiled-in XML)
			\item Implicit tau0 config (compiled-in XML)
			\item Devices
			\item Memory
			\item Channels
			\item Kernel
			\item Subjects
			\item Components
		\end{enumerate}
\end{description}

The Expander performs the following actions:
\begin{itemize}
	\item Add implicit kernel configuration
	\item Add implicit tau0 configuration
	\item Expand device resources
		\begin{itemize}
			\item Add memory resource to global memory
			\item Add device resources to subjects
				\begin{itemize}
					\item Map memory into subject's address space
					\item Add device IRQs
					\item Add device I/O ports
				\end{itemize}
			\item Add device resources to kernel
				\begin{itemize}
					\item Map memory into kernel's address space
				\end{itemize}
		\end{itemize}
	\item Expand kernel memory
		\begin{itemize}
			\item Add kernel binary (physical) memory, use file as memory
				content. Add mapping
			\item Add trampoline memory with fixed physical memory address
				\texttt{0x0}
			\item Add I/O APIC memory, add mapping
			\item Add kernel interface memory, add mapping
			\item Add pagetable memory for all kernels, use files as memory
				content (kernel count = CPU count)
			\item Add VMXON memory for all CPUs
			\item Add stack memory for all kernels
			\item Add storage memory for all kernels
			\item Add mappings for per-CPU memory
				\begin{itemize}
					\item Add mapping for stack memory
					\item Add mapping for per-CPU storage area
				\end{itemize}
		\end{itemize}
	\item Expand subject memory
		\begin{itemize}
			\item Add VMCS memory
			\item Add pagetable memory, use file name as memory content
			\item Add bitmap memory (I/O and MSR), use file names as memory content
			\item Add memory for subject binary, use file name as memory content
			\item Add additional memory, add mapping (TODO: how?)
			\item Expand subject profile/initial state to VCPU element
			\item Run subject-specific expanders (e.g. if Linux add zero page
				memory, use zero page file as memory content)
		\end{itemize}
	\item Expand channels
		\begin{itemize}
			\item Add channel memory to global memory
			\item Map channel memory into subject address space
			\item Add event table entries to source subject
				(if src.cpu /= dst.cpu send IPI).
		\end{itemize}
	\item Adjust subject configuration (e.g. change VMX controls).
\end{itemize}

\subsection{Allocator}
\label{sec:tools-allocator}
The Allocator is responsible to assign a physical address to all global memory
regions.

\begin{description} \itemsep1pt \parskip0pt
	\item[Name] \hfill \\
		\texttt{mucfgalloc}
	\item[Input] \hfill \\
		System policy
	\item[Output] \hfill \\
		System policy, all physical addresses assigned
	\item[Data] \hfill
		\begin{enumerate}
			\item Usable, physical memory blocks
			\item Allocated memory
				\begin{itemize}
					\item Device memory
					\item Fixed physical memory regions
				\end{itemize}
			\item Unallocated memory
		\end{enumerate}
\end{description}

First, the Allocator initializes the physical memory view of the system based on
the physical memory blocks specified in the XML platform section. It then
reserves memory that is occupied by pre-allocated memory elements (i.e. memory
regions with a physical address or device memory). Finally it places all
remaining memory regions in physical memory.
In order to reduce the size of the final system image file-backed memory regions
are placed at the start of memory.

\subsection{Validator}
\label{sec:tools-validator}
The Validator performs additional checks that go beyond the basic restrictions
imposed by the XML schema validation.

\begin{description} \itemsep1pt \parskip0pt
	\item[Name] \hfill \\
		\texttt{mucfgvalidate}
	\item[Input] \hfill \\
		System policy
	\item[Output] \hfill \\
		None, raises exception on error
\end{description}

Examples of checks include:

\begin{itemize}
	\item Assert that references between policy elements are correct (e.g. a
		physical memory	region referenced by a virtual memory region exists)
	\item Assert that memory regions do not overlap
	\item Assert that device interrupts are unique
	\item Assert that no subject has access to system or kernel memory
	\item Assert that non-shareable devices are exclusively assigned to one
		subject
\end{itemize}

\subsection{Structure Generators}
These tools do not change the policy and use it read-only.

\subsubsection{Page Tables}
Generate page tables for kernel(s) and subjects.

\begin{description} \itemsep1pt \parskip0pt
	\item[Name] \hfill \\
		\texttt{mugenpt}
	\item[Input] \hfill \\
		System policy
	\item[Output] \hfill \\
		Page tables of kernels and subjects in binary format
	\item[Output format] \hfill
		\begin{itemize}
			\item IA32-e paging structures, Intel SDM Vol. 3A, section 4.5
			\item EPT paging structures, Intel SDM Vol. 3C, section 28.2
		\end{itemize}
	\item[Data] \hfill
		\begin{enumerate}
			\item Filename
			\item PML4 address
			\item Subject profile
			\item Memory layout (virtual and device memory)
		\end{enumerate}
\end{description}

The tool generates paging structures for subjects and kernels running on each
CPU. These page tables are used to grant access to physical memory according to
the virtual memory layout of the subject. The rest of physical and device memory
is isolated from the subject.

Depending on the subject profile either native 64-bit IA32-e or Extended Page
Tables (EPT) are generated.

An IA32-e page table is generated for each kernel running on a logical CPU.

Page tables are used by the memory management unit (MMU) to enforce isolation of
physical memory according to the system policy.

\subsubsection{VT-d tables}
Generate VT-d tables for each device domain.

\begin{description} \itemsep1pt \parskip0pt
	\item[Name] \hfill \\
		\texttt{mugenvtd}
	\item[Input] \hfill \\
		System policy
	\item[Output] \hfill \\
		VT-d tables of device domains in binary format
	\item[Output format] \hfill \\
		Intel VT-d specification
	\item[Data] \hfill
		\begin{enumerate}
			\item Filename
			\item Device domains
			\item PCI devices
		\end{enumerate}
\end{description}

\subsubsection{I/O Bitmaps}
Generate I/O bitmap for each subject.

\begin{description} \itemsep1pt \parskip0pt
	\item[Name] \hfill \\
		\texttt{mugeniobm}
	\item[Input] \hfill \\
		System policy
	\item[Output] \hfill \\
		I/O bitmaps of subjects in binary format
	\item[Output format] \hfill \\
		Intel SDM Vol. 3C, section 24.6.4
	\item[Data] \hfill
		\begin{enumerate}
			\item Filename
			\item Subject
			\item Device I/O ports
		\end{enumerate}
\end{description}

The tool generates I/O bitmaps for each subject. Access to device I/O ports is
granted according to the device I/O port resources assigned to a subject.

I/O bitmaps are used by the hardware (VT-x) to enforce access to I/O ports
according to the system policy.

\subsubsection{MSR Bitmaps}
Generate MSR bitmap for each subject.

\begin{description} \itemsep1pt \parskip0pt
	\item[Name] \hfill \\
		\texttt{mugenmsrbm}
	\item[Input] \hfill \\
		System policy
	\item[Output] \hfill \\
		MSR bitmaps of subjects in binary format
	\item[Output format] \hfill \\
		Intel SDM Vol. 3C, section 24.6.9
	\item[Data] \hfill
		\begin{enumerate}
			\item Filename
			\item Subject
			\item MSRs
		\end{enumerate}
\end{description}

The tool generates MSR bitmaps for each subject. Access to Model-Specific
Registers (MSRs) is granted according to the MSRs assigned to a subject.

MSR bitmaps are used by the hardware (VT-x) to enforce access to Model-Specific
Registers according to the system policy.

\subsubsection{MSR Stores}
Generate MSR store for each subject with MSR access.

\begin{description} \itemsep1pt \parskip0pt
	\item[Name] \hfill \\
		\texttt{mugenmsrstore}
	\item[Input] \hfill \\
		System policy
	\item[Output] \hfill \\
		MSR store files of subjects in binary format
	\item[Output format] \hfill \\
		Intel SDM Vol. 3C, table 24-11
	\item[Data] \hfill
		\begin{enumerate}
			\item Filename
			\item Subject
			\item MSRs
		\end{enumerate}
\end{description}

The tool generates MSR stores for each subject. The MSR store is used to
save/load MSR values of registers not implicitly handled by hardware on subject
exit/resumption.

MSR stores are used by hardware (VT-x) to enforce isolation of MSR (i.e.
subjects that have access to the same MSRs cannot transfer data via these
registers).

\subsubsection{ACPI Tables}
Generate ACPI tables for all Linux subjects. A set of tables consists of an
RSDP, XSDT, FADT and DSDT table.

\begin{description} \itemsep1pt \parskip0pt
	\item[Name] \hfill \\
		\texttt{mugenacpi}
	\item[Input] \hfill \\
		System policy
	\item[Output] \hfill \\
		ACPI tables of all Linux subjects
	\item[Data] \hfill
		\begin{enumerate}
			\item Filename
			\item Subject name
			\item Memory mappings
			\item Device references
		\end{enumerate}
\end{description}

\subsubsection{Linux Zero Pages}
Generate Zero Pages for all Linux subjects.

\begin{description} \itemsep1pt \parskip0pt
	\item[Name] \hfill \\
		\texttt{mugenzp}
	\item[Input] \hfill \\
		System policy
	\item[Output] \hfill \\
		Zero pages of all Linux subjects
	\item[Data] \hfill
		\begin{enumerate}
			\item Filename
			\item Subject name
			\item Memory mappings
		\end{enumerate}
\end{description}

\subsubsection{Source Specifications}
Generate source specifications used by kernel and subjects.

\begin{description} \itemsep1pt \parskip0pt
	\item[Name] \hfill \\
		\texttt{mugenspec}
	\item[Input] \hfill \\
		System policy
	\item[Output] \hfill \\
		Source specifications in SPARK and C format
\end{description}

Gathers data from the system policy to generate various source files in SPARK
and C format. Created output includes constant values for channel addresses,
device resources, scheduling plans, etc.

\subsubsection{Subject info}
Generate subject information data for each Linux subject.

\begin{description} \itemsep1pt \parskip0pt
	\item[Name] \hfill \\
		\texttt{mugensinfo}
	\item[Input] \hfill \\
		System policy
	\item[Output] \hfill \\
		Subject infor data in binary format
	\item[Output format] \hfill \\
		TBD
	\item[Data] \hfill
		\begin{enumerate}
			\item Filename
			\item Subject
			\item Channel(s)
		\end{enumerate}
\end{description}

\subsection{Packer}
The Packer is responsible to assemble the final system image.

\begin{description} \itemsep1pt \parskip0pt
	\item[Name] \hfill \\
		\texttt{mupack}
	\item[Input] \hfill \\
		System policy, Input directories, System image filename
	\item[Output] \hfill \\
		System image file
	\item[Data] \hfill
		\begin{enumerate}
			\item File
			\item Physical address
		\end{enumerate}
\end{description}

\end{document}
