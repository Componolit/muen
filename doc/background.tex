\chapter{Background}
\section{SPARK}
SPARK is a formally-define high-level programming language designed for writing
high integrity systems. It is based on Ada, which is itself a programming
language with a strong focus on security and safety.

The SPARK language is a subset of Ada with additional features inserted as
annotations by means of Ada comments. Since compilers ignore comments and SPARK
is a true subset of Ada, any correct SPARK program is a correct Ada programm and
can be compiled using existing Ada compilers, such as GNAT, which is part of the
GNU compiler collection (GCC) TODO:ref. However, since annotations are an
integral part of SPARK, it would be misleading to simply consider SPARK a
constrained version of Ada. SPARK should be viewed as a programming language in
its own right.

The annotations are processed by SPARK tools. These tools perform static
analysis of the source code. The annotations allow the tools to do data and
information flow analysis as well as proof the absence of runtime errors. This
means that SPARK tools allow to formally verify, that a given program is free
of errors such as division by zero, out-of-bounds array access etc. The
following program properties can be formally proven using SPARK:

\begin{itemize}
	\item TODO
\end{itemize}

On top of these properties, the usage of pre-/post-conditions and assertions
allow to prove additional functional properties. A proof of (partial
\footnote{Termination cannot be shown}) correctness of SPARK programs is
achievable. This allows to formally show the correspondence of an implementation
with its formal specification.

It is also interesting to note, that has support for tasking in the form a
profile called RavenSPARK TODO:Ref.

SPARK is a mature technology and has garnered quite some interest since it has
been used successfully in several industrial projects TODO:ref. It is primarily
employed in the field of avionics, space, medical systems and in the defense
industry.

\subsection{Design rationale}
The main driving factors behind the design of SPARK are shortly described here:

\begin{description}
	\item[Logical soundness] \hfill \\
		The language must not contain any ambiguities and defined specified.
	\item[Complexity of formal language definition] \hfill \\
		The language must be simple to specify formally.
	\item[Expressive power] \hfill \\
		The language must have rich enough to implement real systems.
	\item[Security] \hfill \\
		All language rules must be statically checkable with reasonable effort
		(within polynomial time).
	\item[Verifiability] \hfill \\
		Program verification must be tractable for industrial scale projects.
	\item[Bounded space and time requirements] \hfill \\
		Resource requirements must be determined statically.
\end{description}

\subsection{Example}
The following listing illustrates how annotations are used to specify the
contract of a subprogram.

\begin{lstlisting}[language=Ada]
type Color_Type is (Red, Green, Blue);

procedure Exchange (X, Y: in out Color_Type);
--# derives X from Y &
--#         Y from X;
--# post X = Y~ and Y = X~;
\end{lstlisting}

An in-depth discussion of the SPARK programming language can be found in
\cite{BarnesSPARK}.

\subsection{SPARK 2014}

\section{Intel x86 Architecture}
\section{Virtualization}
\section{Separation Kernel}
In a system with high requirements on security, functions relevant
to guarantee these requirements must be isolated from the rest of
the system and consolidated in a Trusted Computing Base (TCB)\index{TCB}.
To be trusted, this code must be as minimal as possible to allow formal
verification of code correctness. Lampson et al.
\cite{Lampson:1991:ADS:121133.121160} define the TCB of a computer system as:
\begin{quote}
	A small amount of software and hardware that security depends on and
	that we distinguish from a much larger amount that can misbehave without
	affecting security.
\end{quote}

A separation kernel\index{kernel} (SK\index{SK}) is therefore the fundamental
part of the TCB as its main purpose is to enforce the separation of all other
components making such a component-based system possible in the first place. The
concept of separation kernels was introduced by John Rushby in a paper from 1981
\cite{rushby1981}. While the original paper describes a distributed system, it
is more illustrative to think of it as multiple components which behave as if
they were running on dedicated hardware. The separation kernel must guarantee
that the components can only interact according to a well-defined policy while
running on the same physical hardware.

A system policy dictates the partitioning of hardware resources like CPU, memory
or devices to components. The kernel guarantees this isolation by emulating a
suitable runtime environment for each component, creating the impression of
multipe (virtual) machines. By using modern virtualization techniques, the
kernel is able to delegate certain management tasks to the hardware. This allows
the separation kernel code to be relatively simple, which is a precondition for
formal verification of software.

Because of the simplicity requirement, a system running on top of a separation
kernel is relatively static. The system policy is compiled to a suitable format
on system integration and can not change during runtime. This is is also the
main difference between the separation kernel concept and microkernels which
provide hardware abstraction layers and advanced mechanisms for inter-process
communication (IPC\index{IPC}). A separation kernel does not implement such
functionality, it's sole purpose is to guarantee component separation according
to policy. Policy-writers must make sure that the system specification is sound
and that only allowed communication channels are specified between components.
Of course, this task can be simplified by providing support tools.

\subsection{Subjects}
The separation kernel isolates parts of the TCB into multiple
components\index{component} interacting over well-defined interfaces. In this
paper, such components are called subjects\index{subject}.

As said, only the absolutely necessary features to guarantee subject separation
are present in a separation kernel. Advanced features required to isolate a
complex subject are implemented as dedicated non-privileged subjects. A complex
subject could be a complete operating system like Linux\index{Linux}.

To allow more flexibility, a separation kernel could also use a dedicated
subject to offload management and policy decision tasks. Such a subject runs in
normal unprivileged mode but is allowed to interact with the kernel over a
specialized interface.

\section{Motivation}
\section{Goals}
\section{Related work}
