\chapter{Implementation}
\input{impl_policy}
\input{impl_rts}
\input{impl_subject}

\section{Kernel}
\input{impl_init}
\input{impl_scheduling}
\input{impl_traps}

\subsection{Exceptions and Interrupts}\label{subsec:excp-and-ints}
\begin{figure}[h]
	\centering
	\input{graph_external_interrupt}
	\caption{External interrupt handling}
	\label{fig:external-interrupt}
\end{figure}

\subsection{Multicore support}\label{subsec:mp-support}
The Muen separation kernel makes use of all logical processors available in a
system. The processor count of a specific hardware platform is specified in the
system policy, see section \ref{subsec:hardware}. This section describes how the
multicore setup is done on kernel startup.

Modern PC systems comply to the Intel MultiProcessor (MP\index{MP})
specification. In short, the Intel MP specification is an open-standard
describing enhancements to both operating systems and firmware to be able to
init, boot and operate x86 multiprocessor systems. For more information see
\cite{intel:mp}.

After the hardware completed its part of the MP specification, one processor
has been negotiated to be the bootstrap processor (BSP\index{BSP}). All other
logical processors, called application processors (AP\index{AP}), halt until
they receive a specific inter-processor interrupt (IPI\index{IPI}) sequence.

\begin{figure}[h]
	\centering
	\input{graph_mp_overview}
	\caption{Multicore architecture}
	\label{fig:mp-overview}
\end{figure}

The BSP starts executing code as describe in section \ref{subsec:init}. The
init code initializes the system and jumps into the main SPARK kernel. The
kernel running on the BSP is responsible to bootstrap the other application
processors. It first enables its local APIC\index{APIC} to be able to send
inter-processor interrupts to the halted AP processors. To wakeup the APs, the
INIT-SIPI-SIPI IPI sequence must be sent to their APICs, as described in the MP
specification. See also figure \ref{fig:mp-overview} for an illustration of
this process. The SIPI IPI contains the physical address vector of the
trampoline code copied to low-memory by the init code. The AP processors jump
to this code after wakeup. The trampoline performs the following steps:

\begin{enumerate}
	\item Set up 32-bit GDT\index{GDT}
	\item Switch CPU to protected mode
	\item Initialize DS and SS segments
	\item Jump to the AP entry point in the init code
\end{enumerate}

These steps initialize the APs to the same architectural state as the
bootloader did for the BSP: 32-bit protected mode with paging disabled.
Therefore, the final step is to let the AP processors jump to the identical
init code described in section \ref{subsec:init}.

\subsubsection{Per-kernel memory}
The Muen kernels operate fully symmetrical, i.e. code running on the different
logical processors is (binary) identical. Nevertheless, each kernel owns a
distinct stack page and also a page to store per-CPU data. This however is fully
transparent to the kernels as their virtual stack and global storage addresse
values are the same. This is achieved by using different page table structures
for each kernel. Page tables are created by the policy tool and setup on system
startup by the init code. The main kernel has no access to these structures in
memory and does not bother with memory management.

\subsubsection{Synchronization} Since synchronization is error-prone and it is
desirable to reduce inter-core dependencies as much as possible, the Muen
kernel tries to avoid locks and other synchronization primitives. Nevertheless
minimal synchronization is required at certain key points in the code. This
section describes the spinlock and barrier mechanisms used by the kernel.

\paragraph{Spinlock}
The spinlock implementation uses the \texttt{XCHG} processor instruction to
atomically swap the value one with the contents of a lock variable in memory.
If the result of the set operation is zero, no other core currently holds the
lock and it is successfully acquired. If the result is one, the lock is
currently busy and the core must spin and retry again.

Inside the lock's busy loop the \texttt{PAUSE} instruction is used to improve
performance and resource utilization on CPUs with hyper-threading
(HTT\index{HTT}) enabled TODO:REF.

\paragraph{Barrier}
As described in section \ref{subsec:scheduling}, to guarantee temporal
separation, the scheduling plans on the different logical processors must be
synchronized on major frame transition.

This is achieved by ...

\input{impl_events}
\input{impl_build}
\input{impl_example_system}
