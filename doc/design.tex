\chapter{Design}
The design of the Muen kernel is inspired by the Common Criteria separation
kernel protection profile (SKPP) \cite{SKPP}, which has been used in the
certification of Green Hills' INTEGRITY-178B kernel (see section
\ref{subsec:commercial-sks}). The protection profile has been sunset by the
National Information Assurance Partnership (NIAP) in 2011. Nevertheless we
believe the document can be used as a sound basis and guidance to derive
requirements for a separation kernel appropriate for systems requiring high
robustness.

The separation kernel should allow the construction of systems, that are
potentially exposed to attackers with high attack potential and deployed in the
most difficult threat environment.

\section{Threat model}
The focus of this project is to design and implement a separation kernel, which
guarantees strong separation of subjects and can thus serve as a basis for a
component-based system. This section describes the capabilities of an attacker
and enumerates the issues that are considered out of scope.

\begin{itemize}
	\item All code that is not part of the TCB can potentially be subverted.
		This specifically includes \emph{all} untrusted subjects. Thus an
		attacker can completely control all untrusted subjects.
\end{itemize}

The following issues, while very important in the context of constructing a
high assurance system, are considered out of scope:

\begin{description}
	\item[System initialization] The kernel starts executing after the
		bootloader hands over execution. It is assumed that the system is setup
		and initialized properly. How the system is securely bootstrapped (e.g.
		using a trusted boot process) and initialized and how the integrity of
		the kernel is assured are not considered.
	\item[Hardware] It is assumed, that hardware such as the CPU, memory
		management unit and other devices are working correctly and according to
		their specification. Problems due to buggy or even malicious hardware
		are considered out of scope.
	\item[Physical attacks] Issues predicated on an attacker having physical
		access to the system are not considered.
	\item[Firmware] A modern PC contains firmware and many embedded controllers,
		that are only partly (if at all) controllable by an operating system
		kernel. This includes technologies such as Intel AMT/ME, System
		Management Mode (SMM) and the system BIOS, which have access to
		sensitive system resources.
	\item[Policy validity] The separation kernel provides the mechanisms to
		enforce a given, user-defined policy. The focus is on the correct
		implementation of a provided system configuration. The user is in charge
		of assuring the correctness and consistency of the overall system
		policy.
	\item[Communication] The separation kernel must provide a
		mechanism to establish directed communication channels between subjects.
		It is however not the duty of the kernel to provide a inter-subject
		communication abstraction such as message passing or a remote procedure
		call (RPC) interface.
	\item[Recovery] How a system can be restored to a secure state after a
		compromise is out of scope.
\end{description}

These points must be considered and addressed when building a high assurance
system based on the Muen separation kernel.

\section{Requirements}

The following properties specify the requirements of the separation kernel and
the system's TCB:
\begin{enumerate}
	\item All resources must be protected from unauthorized access. This
		includes devices and memory that has not been assigned to any subject.
	\item System resources internal to the kernel, that are not exported to
		subjects, must not be accessible.
	\item Isolated subjects that do not share any resources must be completely
		separated and not be able to exchange any information.
	\item Information flows between subjects must only be present if explicitly
		specified in the system policy.
	\item A subject must be able to only access its assigned resources. Access
		to other resources must be prohibited.
	\item Assignment of subject resources must be static. A malicious subject
		must not be able to gain access to additional resources or even consume
		all system resources.
	\item All security critical operations must be NEAT: non-bypassable,
		evaluatable, always-invoked and tamperproof.
	\item 64-bit programs must be supported to run as native subjects.
	\item The kernel must support the Intel IA-32e/64-bit architecture and
		system memory larger than 4GB.
	\item The kernel must allow the implementation of small and simple
		components and not impose unnecessary restrictions that would increase
		subject complexity.
\end{enumerate}

\section{Architecture}
\begin{figure}[h]
	\centering
	\input{graph_arch_overview}
	\caption{Architecture overview}
	\label{fig:architecture-overview}
\end{figure}

\subsection{Virtualization}
The core mechanism used to separate subjects is Intel's hardware-assisted
virtualization technology VT-x. The kernel executes in VMX root mode, which
shields it from access by subjects.

\subsubsection{Memory}
All memory resources of a system are static and are explicitly specified in the
system policy. There are no implicitly allocated data structures. This allows
to specify the exact memory layout of the final system at integration time.

The kernel and each subject specifies its memory layout. The memory layout
defines, which physical memory ranges are accessible, their location in the
virtual address space of the binary and additional attributes such as access
rights. Since the layout is controlled by page tables, each subject has its own
distinct set of memory management structures. To assure that a subject cannot
alter the memory layout, it must not have access to any page tables, including
its own.

Figure \ref{fig:phys-mem-layout-example} illustrates the physical memory
structure of an example system.

\begin{figure}[h]
	\centering
	\input{graph_phys_mem_layout_example}
	\caption{Physical memory layout example}
	\label{fig:phys-mem-layout-example}
\end{figure}

The physical memory addresses given on the left side are hexadecimal values.
The memory region containing kernel code and data starts at address 0x10000h
(1 Megabyte (MB)) and has a size of 112 kilobyte (KB). It is followed by a gap of
unallocated memory and then the "subject descriptors" and "$\tau0\rightarrow$
kernel interface" regions which are 4 KB in size. Memory management data
structures of the kernel start at address 0x20000h (2 MB) and expand over 16 KB.
The memory layout of subject $\tau0$ encompasses three regions ranging from
0x21000h to 0x021fffh.

Whenever a subject is executed on the CPU, the MMU is directed to use the
corresponding page tables. The hardware memory management mechanism then
enforces the address translations specified by the paging structures, and thus
restricts the subject to its virtual address space. Figure
\ref{fig:virt-mem-layout-example} illustrates the memory layout of an example
subject.

\begin{figure}[h]
	\centering
	\input{graph_virt_mem_layout_example}
	\caption{Virtual memory layout of example subject}
	\label{fig:virt-mem-layout-example}
\end{figure}

\subsection{Scheduling}\label{subsec:scheduling}
This section presents the design of the Muen kernel scheduler and the selected
scheduling algorithm.

In the context of this work, scheduling is defined as the process of selecting
a subject and giving it access to system resources for a certain amount of time.
The main resource is processor time, which enables a subject to execute and
perform its task.

A key objective of the scheduler is to provide temporal isolation of all
subjects. In order to meet this requirement, the scheduler must prevent any
interference between subjects. To achieve this, scheduling is done in a fixed,
cyclic and preemptive manner.

Subjects are executed for a fixed amount of time, before being preempted by the
scheduler. Preemption means that regardless of what operations a subject is
performing, its execution is suspended when the alloted time quantum has been
consumed. After a subject has been suspended, the scheduler executes the next
subject for a given amount of time.

The information of which subject runs for how long and the chronologic sequence
of subjects is contained in a \emph{scheduling plan}\index{Scheduling plan}.
Such a plan is part of the policy and specifies in what order subjects are
executed in which logical CPU and for how long. The task of scheduler is then to
enforce a given scheduling regime.

A scheduling plan is specified in terms of frames. A \emph{major frame}
\index{Major frame} consists of a sequence of minor frames. When the end of a
major is reached, the scheduler starts over from the beginning and uses the
first minor frame in a cyclic fashion. A \emph{minor frame}\index{Minor frame}
specifies a subject and a precise amount of time. This information is directly
applied by the scheduler.

An example scheduling plan is depicted in figure
\ref{fig:example-scheduling-plan}. It illustrated a system with two logical CPUs
that execute various subjects indicated by different colors. Since major frames
are repeated, major frame one and two are identical. All CPUs of the system
wait on a barrier at the beginning of a new major frame. This guarantees that
all logical CPUs of a system are in-sync on major frame changes.

CPU 0 is executing the same subject for the whole duration of the major frame.
This could for example be the $\tau$0 subject executing on the bootstrap
processor (BSP). The second CPU is executing two subjects (blue and green) in
alternating order. As can be seen, subject green is granted more CPU cycles than
subject blue.

\begin{figure}[ht]
	\begin{ganttchart}[
		vgrid={*9{dotted},*1{dashed},*9{dotted}},
		hgrid,
		y unit title=0.75cm,
		title label anchor/.style={below=-1.5ex}]{20}
		\gantttitle{Major frame 1}{10}
		\gantttitle{Major frame 2}{10} \\
		\ganttbar[bar/.append style={fill=Apricot}]{CPU 0}{1}{10}
		\ganttbar[bar/.append style={fill=Apricot}]{}{11}{20} \\
		\ganttbar[bar/.append style={fill=CornflowerBlue}]{CPU 1}{1}{2}
		\ganttbar[bar/.append style={fill=YellowGreen}]{}{3}{6}
		\ganttbar[bar/.append style={fill=CornflowerBlue}]{}{7}{8}
		\ganttbar[bar/.append style={fill=YellowGreen}]{}{9}{10}
		\ganttbar[bar/.append style={fill=CornflowerBlue}]{}{11}{12}
		\ganttbar[bar/.append style={fill=YellowGreen}]{}{13}{16}
		\ganttbar[bar/.append style={fill=CornflowerBlue}]{}{17}{18}
		\ganttbar[bar/.append style={fill=YellowGreen}]{}{19}{20}
	\end{ganttchart}
	\caption{Example scheduling plan}
	\label{fig:example-scheduling-plan}
\end{figure}

On systems with multiple logical CPUs, a scheduling plan must specify a sequence
of minor frames for each processor core. In order for the cores to not run out
of sync, all major frames must be of equal length. This means that the sum of
all minor frame time slices of all major frames of a given scheduling plan must
amount to the same time duration.

Figure \ref{fig:example-scheduling-plan-of-a-cpu} illustrates the scheduling
plan for a specific CPU. The major frame consists of four minor frames. Minor
frame two has twice the amount of ticks than the other minor frames, which have
identical length.

When the major frame starts, subject one is scheduled for the length of minor
frame one, followed by a switch to subject 2. After that the two subjects are
again scheduled in alternating fashion.

\begin{figure}[ht]
	\begin{ganttchart}[
		vgrid={*3{dotted},*1{dashed},*7{dotted},*1{dashed},*3{dotted},*1{dashed},*3{dotted}},
		hgrid,
		y unit title=0.75cm,
		title label anchor/.style={below=-1.5ex}]{20}
		\gantttitle{Major frame}{20} \\
		\gantttitle{Minor 1}{4}
		\gantttitle{Minor 2}{8}
		\gantttitle{Minor 3}{4}
		\gantttitle{Minor 4}{4} \\
		\ganttbar[bar/.append style={fill=CornflowerBlue}]{Subject 1}{1}{4}
		\ganttbar[bar/.append style={fill=CornflowerBlue}]{}{13}{16} \\
		\ganttbar[bar/.append style={fill=YellowGreen}]{Subject 2}{5}{12}
		\ganttbar[bar/.append style={fill=YellowGreen}]{}{17}{20}
	\end{ganttchart}
	\caption{Example scheduling plan of a CPU}
	\label{fig:example-scheduling-plan-of-a-cpu}
\end{figure}

Since a system performs diverse tasks with different resource requirements,
there is a need for some flexibility with regards to scheduling. To provide this
degree of freedom while keeping the kernel complexity low, multiple scheduling
plans can be specified in the system policy. The privileged subject $\tau$0 is
then allowed to select and activate one of these scheduling plans. The kernel
enforces the current plan designated by $\tau$0.

By defining a distinct plan for each anticipated workload at integration time,
the scheduling regimes are fixed at integration time. This removes any runtime
uncertainty that might be introduced by making this mechanism, since the
scheduling plans cannot be altered at runtime.
