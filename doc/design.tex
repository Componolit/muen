\chapter{Design}
The design of the Muen kernel is inspired by the Common Criteria separation
kernel protection profile (SKPP) \cite{SKPP}, which has been used in the
certification of Green Hills' INTEGRITY-178B kernel (see section
\ref{subsec:commercial-sks}). The protection profile has been sunset by the
National Information Assurance Partnership (NIAP) in 2011. Nevertheless we
believe the document can be used as a sound basis and guidance to derive
requirements for a separation kernel appropriate for systems requiring high
robustness.

The separation kernel should allow the construction of systems, that are
potentially exposed to attackers with high attack potential and deployed in the
most difficult threat environment.

\input{des_threat_model}

\input{des_requirements}

\input{des_subject}

\section{Architecture}
The core mechanism used to separate subjects is Intel's hardware-assisted
virtualization technology VT-x. The kernel executes in VMX root mode, while
subjects run in VMX non-root mode. This shields the kernel from access by
subjects. Figure \ref{fig:architecture-overview} illustrates the basic system
architecture: the Muen kernel executes two isolated subjects that have no access
to any kernel resources. The native subject is a bare bones application and the
second subject is a virtual machine (VM) type subject, e.g. full operating
system.

\begin{figure}[h]
	\centering
	\input{graph_arch_overview}
	\caption{Architecture overview}
	\label{fig:architecture-overview}
\end{figure}

\subsection{Subject execution}
The kernel runs a subject by setting up the environment and executing the binary
code defined by the subject specification. Initially the subject state is set to
the specified initial state. The subject starts running for a predefined period
of time (see \ref{subsec:scheduling}). Once the time has passed, the current
state of the subject is saved by the kernel for later resumption.

The execution of subject code is preempted and the kernel is invoked by
transitioning from VMX non-root to root mode. Such a transition is called a
trap. TODO:(Move traps etc text from implementation chapter?)

A subject is constrained to the environment specified by the subject profile and
the resources assigned to it by the policy. If a subject performs an illegal
resource access or performs an operation not allowed by the profile, a trap
occurs and the kernel is invoked. The kernel can then determine the cause for
the transition and handle the condition properly according to policy.

\subsection{Policy}
To best fulfill the requirements, a system using the Muen kernel uses static
resource assignment and system specification. The main idea is to have a
complete description of the system including all resources such as system
memory, devices and subjects in the form of a policy. The defined resources can
be assigned to subjects. Since the resources and subjects are fixed at
integration time, the policy can be analyzed and validated prior to execution.

The following list encompasses parts of a system policy:
\begin{itemize}
	\item Hardware resources
	\item Subject specifications
	\item Scheduling
\end{itemize}

\subsubsection{Memory}
All memory resources of a system are static and are explicitly specified in the
system policy. Apart from a few special memory regions, such as the application
processor trampoline (see section \ref{subsec:init}), there are no implicitly
allocated data structures. This allows to determine the exact memory layout of
the final system at integration time.

The kernel and each subject specifies its memory layout. The memory layout
defines, which physical memory ranges are accessible, their location in the
virtual address space of the binary and additional attributes such as access
rights. Since the layout is controlled by memory management data structures,
each subject has its own distinct set of page tables. To assure that a subject
cannot alter the memory layout, it must not have access to any page tables,
including its own. This is achieved by not mapping memory management structures
into the address space of a subject.

Figure \ref{fig:phys-mem-layout-example} illustrates the physical memory
structure of an example system.

\begin{figure}[h]
	\centering
	\input{graph_phys_mem_layout_example}
	\caption{Physical memory layout example}
	\label{fig:phys-mem-layout-example}
\end{figure}

The physical memory addresses given on the left side are hexadecimal values.
The memory region containing kernel code and data starts at address
\texttt{0x100000h} (1 Megabyte (MB)) and has a size of 112 kilobyte (KB). It is
followed by a gap of unallocated memory and then the "subject descriptors" and
"$\tau0\rightarrow$ kernel interface" regions which are each 4 KB in size.
Memory management data structures of the kernel start at address
\texttt{0x200000h} (2 MB) and expand over 16 KB. The memory layout of subject
$\tau0$ encompasses three regions ranging from \texttt{0x210000h} to
\texttt{0x0219fffh}.

Since the address space of a subject cannot change, the page tables are static
as well, which means they can be generated according to the relevant information
in the system policy. Whenever a subject is executed on the CPU, the kernel
directs the MMU to use the corresponding paging structures. The hardware memory
management mechanism then enforces the address translations specified by the
page tables, ultimately restricting the subject to the virtual address space
specified by the policy. Figure \ref{fig:virt-mem-layout-example} illustrates
the memory layout of an example subject.

\begin{figure}[h]
	\centering
	\input{graph_virt_mem_layout_example}
	\caption{Virtual memory layout of example subject}
	\label{fig:virt-mem-layout-example}
\end{figure}

The size and the physical as well as the virtual address of each memory region
is specified in the policy. Additional attributes such as read/write access
rights, if the region may contain executable program code and the type of memory
with regards to caching behavior are also configured via the policy.

\subsubsection{Devices}
A device can be modeled as a collection of system resources such as I/O ports,
system memory for memory-mapped IO (MMIO) or hardware interrupts. A PS/2
keyboard for example is composed of two I/O ports and a hardware interrupt.
In order for subjects to use a device, it must be able to access the I/O ports
and process the interrupts raised by the device. Thus a policy device
specification links a device name with a set of hardware resources. Assignment
to subjects is done via references to devices in the subject specification.
Devices that are not allocated to a subject are not accessible during the
runtime of the system.

Like any other resource, care must be taken if a device is shared by multiple
subjects since it can be used to transfer information. This is true for any
shared resource.

\subsubsection{Processor}
Information about the processor of the system must also be specified in the
policy, since the number of available logical CPUs for example is crucial for
scheduling. This allows to verify the consistency of the scheduling plan with
regards to the processor that the system is executing on.

\subsection{Inter-subject communication}
The Muen kernel provides two main mechanisms for information flow between
subjects: shared memory and so caled events. The first mechanism can be used to
share arbitrary data between subjects while events are method to pass
notifications between subjects in the form of injected interrupts.

All communication paths, be it shared memory regions or events, are specified as
part of the subject specification in the system policy. This means that all
channels that provide means for subjects to exchange information are explicit
and cannot change during the runtime of the system. This allows to validate all
inter-subject information flows prior to execution.

\subsubsection{Shared memory}
The main mechanism for subjects to exchange data is to specify a common shared
memory region in the system policy. A memory region is shared, if two or more
subject memory layouts specify a region that map the same physical memory range.

Access rights for memory regions (e.g. write access) are part of the subject
memory layout. This allows to specify a direction of information flow for memory
regions, e.g. by granting write access to the source subject exclusively and
giving the destination subject read access only.

Since memory management is static and exclusively governed by the system policy,
the kernel does not need to make special provisions. This avoids adding
complexity to the kernel by (re-)using the already necessary memory management
mechanisms.

The kernel does not provide a higher level abstraction than shared memory.
Subjects must implement their own protocol, such as message passing, based on
the shared memory region and or events.

\subsubsection{Events}
An event is caused by a subject and leads to the delivery or injection of an
interrupt to a specific destination subject. The subject triggering or sending
the signal is called the source subject. Signals facilitate the implementation
of a simple inter-subject notification mechanism and enable event-driven
services such as the use case presented in section \ref{subsec:use-cases}. TODO

Events are explicitly triggered by a given source subject and are part of the
subject specification. The subject policy contains a list of event table entries
that specify the event number, destination subject and interrupt number to
inject.

When a subject triggers an event, it invokes a hypercall passing an event number
as parameter to the kernel. The kernel then consults the subject's event table
to determine the destination subject and vector. If a valid entry is present, an
interrupt with the specified interrupt number is injected into the destination
subject. If the event number is invalid (e.g. not in the range of the subject's
event table) the event is ignored.

\subsection{Exceptions}\label{subsec:design-exceptions}
We distinguish software exceptions that occur in VMX non-root mode, while
executing a subject, and in VMX root mode when the kernel is operating.

As the kernel is implemented in the SPARK programming language and the absence
of runtime errors is proven, exceptions during regular operation in VMX
root-mode should not happen. If for some unforseen reason (e.g. non-maskable
interrupt NMI) an exception occurs, it indicates a serious error and the system
is halted.

In the cause of an exception being caused by the execution of a subject, the
exception handling is different depending on the profile of the running subject.

If a native subject causes an exception, a trap occurs with the exit reason
indicating such a condition. Thus the kernel consults the subject's trap table
to determine what subject is in charge of handling the trap and thus ultimately
the exception raised by the source subject.

VM subjects are able to perform their own exception handling. Thus if such a
subject causes an exception, it is delivered to the subject's exception handler
by means of its interrupt descriptor table (IDT) TODO:Ref. A trap occurs if the
subject is somehow not able to handle the exception properly and a triple fault
occurs (e.g. a nested exception occurs in the exception handler and the subject
has not installed a double fault handler).
The trap is then processed by the kernel like any other trap caused by the
subject by using the trap table to schedule the destination subject according to
the policy.

\subsection{Interrupts}
Devices can generate hardware interrupts that must be delivered to the subject
that controls the device according to the policy. A device specification in the
system policy defines what hardware interrupt it generates. Devices are assigned
to subjects by means of device references in the subject specification part.

Since resource allocation is static, a global mapping of hardware interrupt to
destination subject can be compiled at integration time. The kernel then uses
this mapping at runtime when a device raises a hardware interrupt to determine
the destination subject, that constitutes the final recipient of the interrupt.

Each subject has a list of pending interrupts. An interrupt is delivered to a
subject by appending an entry to the interrupt list of the destination subject.
When the execution of a subject is resumed, the kernel consults this list and
injects the interrupt.

Spurious or invalid interrupts that have not valid interrupt to subject mapping
are ignored by the kernel.

\input{des_scheduling}
