\chapter{Design}
The design of the Muen kernel is inspired by the Common Criteria separation
kernel protection profile (SKPP) \cite{SKPP}, which has been used in the
certification of Green Hills' INTEGRITY-178B kernel (see section
\ref{subsec:commercial-sks}). The protection profile has been sunset by the
National Information Assurance Partnership (NIAP) in 2011. Nevertheless we
believe the document can be used as a sound basis and guidance to derive
requirements for a separation kernel appropriate for systems requiring high
robustness.

The separation kernel should allow the construction of systems, that are
potentially exposed to attackers with high attack potential and deployed in the
most difficult threat environment.

\input{des_threat_model}

\input{des_requirements}

\section{Subject concept}
A subject is an untrusted software component that is executed by the separation
kernel. Similar terms used in literature are partition or component. Besides the
separation kernel itself, subjects constitute the majority of a system based on
the Muen kernel.

The main purpose of the kernel is to execute an arbitrary number of subjects,
giving them access to assigned resources and only allowing communication between
subjects via explicitly defined channels. The kernel treats all subjects equally.

We categorize the information related to a subject into two distinct categories:

\begin{description}
	\item[Specification] encompasses all static configuration data, that is
		constant and does not change during the runtime of the system, e.g.
		assigned hardware devices.
	\item[State] is made up of all transient values that are potentially modified
		by the execution of a subject, e.g. CPU register values.
\end{description}

\subsection{Subject specification}
The specification defines, what resources a subject is allowed to access, what
environment the kernel must provide for the subject, the initial state of the
execution environment and of course the subject binary itself.

This information is part of the overall system specification and is fixed at
integration time. It does not change during the execution of the system. The
kernel keeps this information as part of the compiled system policy in read-only
memory. Since subjects are unable to access kernel memory, the subject
specifications cannot be tampered with and change.

\subsection{Subject state}
Running a subject changes the execution environment. The state of a subject
encompasses all system elements that are visible to the subject and can contain
different information depending on the current subject. In particular this
encompasses the CPU registers, instruction and stack pointer as well as control
register values.

Since the kernel can pause and resume subject execution and potentially multiple
subjects can be executed in arbitrary order the state of the system as viewed by
the subject must be saved. The state must be restored accurately upon resumption
otherwise the subject will not be able to execute seamlessly. Additionally, if a
subject is not oblivious to the fact that the kernel is saving and loading its
state, the isolation of the subject would be insufficient since this would be an
unintended information flow.

\subsection{Subject profile}
Two types of subjects are distinguished:

\begin{itemize}
	\item Native applications
	\item Virtual Machine (VM) subjects
\end{itemize}

Each of these types is captured by so called subject profiles. These profiles
determine the execution environment and architectural features (e.g. memory
management) the subject is allowed to use. The profiles are described in the
following sections.

\subsubsection{Native subject}
A \emph{native} subject is an 64-bit application, that executes directly on the
processor without any supporting operating system kernel or runtime environment.
Such applications may also be called bare bones or bare metal.

The execution environment of the native subject profile has the following main
properties:

\begin{itemize}
	\item IA-32e/64-bit processor mode
	\item No mode switching
	\item No memory management/static paging structures
	\item No exception handling
	\item No control register access
\end{itemize}

\subsubsection{VM subject}
A \emph{virtual machine} (VM) subject has more control over its execution
environment and the VM profile is intended for running whole operating systems
such as xv6 or Linux.

The execution environment of the VM subject profile has the following main
properties:

\begin{itemize}
	\item Switching between 32-bit and 64-bit modes
	\item Memory management and page table management
	\item Exception handling via IDT
	\item Restricted control register access
\end{itemize}

\section{Architecture}
The core mechanism used to separate subjects is Intel's hardware-assisted
virtualization technology VT-x. The kernel executes in VMX root mode, while
subjects run in VMX non-root mode. This shields the kernel from access by
subjects. Figure \ref{fig:architecture-overview} illustrates the basic system
architecture: the Muen kernel executes two isolated subjects that have no access
to any kernel resources. The native subject is a bare bones application and the
second subject is a virtual machine (VM) type subject, e.g. full operating
system.

\begin{figure}[h]
	\centering
	\input{graph_arch_overview}
	\caption{Architecture overview}
	\label{fig:architecture-overview}
\end{figure}

\subsection{Subject execution}
The kernel runs a subject by setting up the environment and executing the binary
code defined by the subject specification. Initially the subject state is set to
the specified initial state. The subject starts running for a predefined period
of time (see \ref{subsec:scheduling}). Once the time has passed, the current
state of the subject is saved by the kernel for later resumption.

The execution of subject code is preempted and the kernel is invoked by
transitioning from VMX non-root to root mode. Such a transition is called a
trap. TODO:(Move traps etc text from implementation chapter?)

A subject is constrained to the environment specified by the subject profile and
the resources assigned to it by the policy. If a subject performs an illegal
resource access or performs an operation not allowed by the profile, a trap
occurs and the kernel is invoked. The kernel can then determine the cause for
the transition and handle the condition properly according to policy.

\subsection{Policy}
To best fulfill the requirements, a system using the Muen kernel uses static
resource assignment and system specification. The main idea is to have a
complete description of the system including all resources such as system
memory, devices and subjects in the form of a policy. The defined resources can
be assigned to subjects. Since the resources and subjects are fixed at
integration time, the policy can be analyzed and validated prior to execution.

The following list encompasses parts of a system policy:
\begin{itemize}
	\item Hardware resources
	\item Subject specifications
	\item Scheduling
\end{itemize}

\subsubsection{Memory}
All memory resources of a system are static and are explicitly specified in the
system policy. Apart from a few special memory regions, such as the application
processor trampoline (see section \ref{subsec:init}), there are no implicitly
allocated data structures. This allows to determine the exact memory layout of
the final system at integration time.

The kernel and each subject specifies its memory layout. The memory layout
defines, which physical memory ranges are accessible, their location in the
virtual address space of the binary and additional attributes such as access
rights. Since the layout is controlled by memory management data structures,
each subject has its own distinct set of page tables. To assure that a subject
cannot alter the memory layout, it must not have access to any page tables,
including its own. This is achieved by not mapping memory management structures
into the address space of a subject.

Figure \ref{fig:phys-mem-layout-example} illustrates the physical memory
structure of an example system.

\begin{figure}[h]
	\centering
	\input{graph_phys_mem_layout_example}
	\caption{Physical memory layout example}
	\label{fig:phys-mem-layout-example}
\end{figure}

The physical memory addresses given on the left side are hexadecimal values.
The memory region containing kernel code and data starts at address
\texttt{0x100000h} (1 Megabyte (MB)) and has a size of 112 kilobyte (KB). It is
followed by a gap of unallocated memory and then the "subject descriptors" and
"$\tau0\rightarrow$ kernel interface" regions which are each 4 KB in size.
Memory management data structures of the kernel start at address
\texttt{0x200000h} (2 MB) and expand over 16 KB. The memory layout of subject
$\tau0$ encompasses three regions ranging from \texttt{0x210000h} to
\texttt{0x0219fffh}.

Since the address space of a subject cannot change, the page tables are static
as well, which means they can be generated according to the relevant information
in the system policy. Whenever a subject is executed on the CPU, the kernel
directs the MMU to use the corresponding paging structures. The hardware memory
management mechanism then enforces the address translations specified by the
page tables, ultimately restricting the subject to the virtual address space
specified by the policy. Figure \ref{fig:virt-mem-layout-example} illustrates
the memory layout of an example subject.

\begin{figure}[h]
	\centering
	\input{graph_virt_mem_layout_example}
	\caption{Virtual memory layout of example subject}
	\label{fig:virt-mem-layout-example}
\end{figure}

The size and the physical as well as the virtual address of each memory region
is specified in the policy. Additional attributes such as read/write access
rights, if the region may contain executable program code and the type of memory
with regards to caching behavior are also configured via the policy.

\subsubsection{Devices}
A device can be modeled as a collection of system resources such as I/O ports,
system memory for memory-mapped IO (MMIO) or hardware interrupts. A PS/2
keyboard for example is composed of two I/O ports and a hardware interrupt.
In order for subjects to use a device, it must be able to access the I/O ports
and process the interrupts raised by the device. Thus a policy device
specification links a device name with a set of hardware resources. Assignment
to subjects is done via references to devices in the subject specification.
Devices that are not allocated to a subject are not accessible during the
runtime of the system.

Like any other resource, care must be taken if a device is shared by multiple
subjects since it can be used to transfer information. This is true for any
shared resource.

\subsubsection{Processor}
Information about the processor of the system must also be specified in the
policy, since the number of available logical CPUs for example is crucial for
scheduling. This allows to verify the consistency of the scheduling plan with
regards to the processor that the system is executing on.

\subsection{Inter-subject communication}
The Muen kernel provides two main mechanisms for information flow between
subjects: shared memory and so caled events. The first mechanism can be used to
share arbitrary data between subjects while events are method to pass
notifications between subjects in the form of injected interrupts.

All communication paths, be it shared memory regions or events, are specified as
part of the subject specification in the system policy. This means that all
channels that provide means for subjects to exchange information are explicit
and cannot change during the runtime of the system. This allows to validate all
inter-subject information flows prior to execution.

\subsubsection{Shared memory}
The main mechanism for subjects to exchange data is to specify a common shared
memory region in the system policy. A memory region is shared, if two or more
subject memory layouts specify a region that map the same physical memory range.

Access rights for memory regions (e.g. write access) are part of the subject
memory layout. This allows to specify a direction of information flow for memory
regions, e.g. by granting write access to the source subject exclusively and
giving the destination subject read access only.

Since memory management is static and exclusively governed by the system policy,
the kernel does not need to make special provisions. This avoids adding
complexity to the kernel by (re-)using the already necessary memory management
mechanisms.

The kernel does not provide a higher level abstraction than shared memory.
Subjects must implement their own protocol, such as message passing, based on
the shared memory region and or events.

\subsubsection{Events}
An event is caused by a subject and leads to the delivery or injection of an
interrupt to a specific destination subject. The subject triggering or sending
the signal is called the source subject. Signals facilitate the implementation
of a simple inter-subject notification mechanism and enable event-driven
services such as the use case presented in section \ref{subsec:use-cases}. TODO

Events are explicitly triggered by a given source subject and are part of the
subject specification. The subject policy contains a list of event table entries
that specify the event number, destination subject and interrupt number to
inject.

When a subject triggers an event, it invokes a hypercall passing an event number
as parameter to the kernel. The kernel then consults the subject's event table
to determine the destination subject and vector. If a valid entry is present, an
interrupt with the specified interrupt number is injected into the destination
subject. If the event number is invalid (e.g. not in the range of the subject's
event table) the event is ignored.

\subsection{Exceptions}
We distinguish software exceptions that occur in VMX non-root mode, while
executing a subject, and in VMX root mode when the kernel is operating.

As the kernel is implemented in the SPARK programming language and the absence
of runtime errors is proven, exceptions during regular operation in VMX
root-mode should not happen. If for some unforseen reason (e.g. non-maskable
interrupt NMI) an exception occurs, it indicates a serious error and the system
is halted.

In the cause of an exception being caused by the execution of a subject, the
exception handling is different depending on the profile of the running subject.

If a native subject causes an exception, a trap occurs with the exit reason
indicating such a condition. Thus the kernel consults the subject's trap table
to determine what subject is in charge of handling the trap and thus ultimately
the exception raised by the source subject.

VM subjects are able to perform their own exception handling. Thus if such a
subject causes an exception, it is delivered to the subject's exception handler
by means of its interrupt descriptor table (IDT) TODO:Ref. A trap occurs if the
subject is somehow not able to handle the exception properly and a triple fault
occurs (e.g. a nested exception occurs in the exception handler and the subject
has not installed a double fault handler).
The trap is then processed by the kernel like any other trap caused by the
subject by using the trap table to schedule the destination subject according to
the policy.

\subsection{Interrupts}
Devices can generate hardware interrupts that must be delivered to the subject
that controls the device according to the policy. A device specification in the
system policy defines what hardware interrupt it generates. Devices are assigned
to subjects by means of device references in the subject specification part.

Since resource allocation is static, a global mapping of hardware interrupt to
destination subject can be compiled at integration time. The kernel then uses
this mapping at runtime when a device raises a hardware interrupt to determine
the destination subject, that constitutes the final recipient of the interrupt.

Each subject has a list of pending interrupts. An interrupt is delivered to a
subject by appending an entry to the interrupt list of the destination subject.
When the execution of a subject is resumed, the kernel consults this list and
injects the interrupt.

Spurious or invalid interrupts that have not valid interrupt to subject mapping
are ignored by the kernel.

\subsection{Scheduling}\label{subsec:scheduling}
This section presents the design of the Muen kernel scheduler and the selected
scheduling algorithm.

In the context of this work, scheduling is defined as the process of selecting
a subject and giving it access to system resources for a certain amount of time.
The main resource is processor time, which enables a subject to execute and
perform its task.

A key objective of the scheduler is to provide temporal isolation of all
subjects. In order to meet this requirement, the scheduler must prevent any
interference between subjects. To achieve this, scheduling is done in a fixed,
cyclic and preemptive manner.

Subjects are executed for a fixed amount of time, before being preempted by the
scheduler. Preemption means that regardless of what operations a subject is
performing, its execution is suspended when the alloted time quantum has been
consumed. After a subject has been suspended, the scheduler executes the next
subject for a given amount of time.

The information of which subject runs for how long and the chronologic sequence
of subjects is contained in a \emph{scheduling plan}\index{Scheduling plan}.
Such a plan is part of the policy and specifies in what order subjects are
executed in which logical CPU and for how long. The task of scheduler is then to
enforce a given scheduling regime.

A scheduling plan is specified in terms of frames. A \emph{major frame}
\index{Major frame} consists of a sequence of minor frames. When the end of a
major is reached, the scheduler starts over from the beginning and uses the
first minor frame in a cyclic fashion. A \emph{minor frame}\index{Minor frame}
specifies a subject and a precise amount of time. This information is directly
applied by the scheduler.

An example scheduling plan is depicted in figure
\ref{fig:example-scheduling-plan}. It illustrated a system with two logical CPUs
that execute various subjects indicated by different colors. Since major frames
are repeated, major frame one and two are identical. All CPUs of the system
wait on a barrier at the beginning of a new major frame. This guarantees that
all logical CPUs of a system are in-sync on major frame changes.

CPU 0 is executing the same subject for the whole duration of the major frame.
This could for example be the $\tau$0 subject executing on the bootstrap
processor (BSP). The second CPU is executing two subjects (blue and green) in
alternating order. As can be seen, subject green is granted more CPU cycles than
subject blue.

\begin{figure}[ht]
	\begin{ganttchart}[
		vgrid={*9{dotted},*1{dashed},*9{dotted}},
		hgrid,
		y unit title=0.75cm,
		title label anchor/.style={below=-1.5ex}]{20}
		\gantttitle{Major frame 1}{10}
		\gantttitle{Major frame 2}{10} \\
		\ganttbar[bar/.append style={fill=Apricot}]{CPU 0}{1}{10}
		\ganttbar[bar/.append style={fill=Apricot}]{}{11}{20} \\
		\ganttbar[bar/.append style={fill=CornflowerBlue}]{CPU 1}{1}{2}
		\ganttbar[bar/.append style={fill=YellowGreen}]{}{3}{6}
		\ganttbar[bar/.append style={fill=CornflowerBlue}]{}{7}{8}
		\ganttbar[bar/.append style={fill=YellowGreen}]{}{9}{10}
		\ganttbar[bar/.append style={fill=CornflowerBlue}]{}{11}{12}
		\ganttbar[bar/.append style={fill=YellowGreen}]{}{13}{16}
		\ganttbar[bar/.append style={fill=CornflowerBlue}]{}{17}{18}
		\ganttbar[bar/.append style={fill=YellowGreen}]{}{19}{20}
	\end{ganttchart}
	\caption{Example scheduling plan}
	\label{fig:example-scheduling-plan}
\end{figure}

On systems with multiple logical CPUs, a scheduling plan must specify a sequence
of minor frames for each processor core. In order for the cores to not run out
of sync, all major frames must be of equal length. This means that the sum of
all minor frame time slices of all major frames of a given scheduling plan must
amount to the same time duration.

Figure \ref{fig:example-scheduling-plan-of-a-cpu} illustrates the scheduling
plan for a specific CPU. The major frame consists of four minor frames. Minor
frame two has twice the amount of ticks than the other minor frames, which have
identical length.

When the major frame starts, subject one is scheduled for the length of minor
frame one, followed by a switch to subject 2. After that the two subjects are
again scheduled in alternating fashion.

\begin{figure}[ht]
	\begin{ganttchart}[
		vgrid={*3{dotted},*1{dashed},*7{dotted},*1{dashed},*3{dotted},*1{dashed},*3{dotted}},
		hgrid,
		y unit title=0.75cm,
		title label anchor/.style={below=-1.5ex}]{20}
		\gantttitle{Major frame}{20} \\
		\gantttitle{Minor 1}{4}
		\gantttitle{Minor 2}{8}
		\gantttitle{Minor 3}{4}
		\gantttitle{Minor 4}{4} \\
		\ganttbar[bar/.append style={fill=CornflowerBlue}]{Subject 1}{1}{4}
		\ganttbar[bar/.append style={fill=CornflowerBlue}]{}{13}{16} \\
		\ganttbar[bar/.append style={fill=YellowGreen}]{Subject 2}{5}{12}
		\ganttbar[bar/.append style={fill=YellowGreen}]{}{17}{20}
	\end{ganttchart}
	\caption{Example scheduling plan of a CPU}
	\label{fig:example-scheduling-plan-of-a-cpu}
\end{figure}

Since a system performs diverse tasks with different resource requirements,
there is a need for some flexibility with regards to scheduling. To provide this
degree of freedom while keeping the kernel complexity low, multiple scheduling
plans can be specified in the system policy. The privileged subject $\tau$0 is
then allowed to select and activate one of these scheduling plans. The kernel
enforces the current plan designated by $\tau$0.

By defining a distinct plan for each anticipated workload at integration time,
the scheduling regimes are fixed at integration time. This removes any runtime
uncertainty that might be introduced by making this mechanism, since the
scheduling plans cannot be altered at runtime.
