

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>6. The Schema module &mdash; XML/Ada: the XML Library for Ada 4.3w documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '4.3w',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="top" title="XML/Ada: the XML Library for Ada 4.3w documentation" href="index.html" />
    <link rel="next" title="7. Using the library" href="using.html" />
    <link rel="prev" title="5. The DOM module" href="dom.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="using.html" title="7. Using the library"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="dom.html" title="5. The DOM module"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">XML/Ada: the XML Library for Ada 4.3w documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/adacore_transparent.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">6. The Schema module</a><ul>
<li><a class="reference internal" href="#xml-grammars">6.1. XML Grammars</a></li>
<li><a class="reference internal" href="#xml-schema-syntax">6.2. XML Schema Syntax</a></li>
<li><a class="reference internal" href="#connecting-xml-documents-and-schemas">6.3. Connecting XML documents and schemas</a></li>
<li><a class="reference internal" href="#validating-documents-with-sax">6.4. Validating documents with SAX</a></li>
<li><a class="reference internal" href="#validating-documents-with-dom">6.5. Validating documents with DOM</a></li>
<li><a class="reference internal" href="#unsupported-schema-elements">6.6. Unsupported schema elements</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="dom.html"
                        title="previous chapter">5. The DOM module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="using.html"
                        title="next chapter">7. Using the library</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/schema.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="the-schema-module">
<span id="id1"></span><h1>6. The Schema module<a class="headerlink" href="#the-schema-module" title="Permalink to this headline">¶</a></h1>
<div class="section" id="xml-grammars">
<h2>6.1. XML Grammars<a class="headerlink" href="#xml-grammars" title="Permalink to this headline">¶</a></h2>
<p>There are several steps that applications must go through when they have to use
XML files:</p>
<ul>
<li><p class="first">Make sure the XML file is well-formed.</p>
<p>This is a basic step where we ensure that XML tags are correctly nested, that
closing tags have the same names as the matching opening tags, that attribute
values are quoted,.... This corresponds to a syntactic parser in a compiler.</p>
<p>This step does not depend on the application domain. One file that is
well-formed will always be so, no matter in what context you use it.</p>
</li>
<li><p class="first">Make sure the contents of the XML file is semantically valid.</p>
<p>Depending on the application domain, we must ensure that the content of the
file makes sense. This step is highly application dependent, and a file that
is usable in one application might not be usable in another one.</p>
<p>This is the phase in which the application needs to check whether a given XML
file has all its required attributes, whether the children of an XML tag are
the expected ones, whether the type of the attributes is valid,....</p>
</li>
<li><p class="first">Use the XML file in the application.</p>
<p>This is done through the already-described SAX or DOM parsers</p>
</li>
</ul>
<p>The first phase is mandatory, and necessarily enforced by XML/Ada. You will not
be able to access the contents of the XML file if it isn&#8217;t well-formed.</p>
<p>The second phase is provided by the Schema module in XML/Ada. Although such
constraints can be checked at the application level, with ad hoc code, it is
generally easier to maintain a separate file that describes the valid semantic
contents of the file, that maintain specific code when the semantic changes. It
is also difficult not to forget special cases when doing the validating through
a set of <cite>if</cite> statements in the Ada core.</p>
<p>XML provides two ways to describe additional constraints that a file must
satisfy in order to be considered as valid.</p>
<ul>
<li><p class="first">DTD</p>
<p>The Document Type Description is the original way to do this. They come
directly from the ancestor of XML, SGML. All XML parsers must parse the DTD,
and report events if the user is using SAX. However, not all parsers are able
to validate the document against a DTD (XML/Ada doesn&#8217;t).</p>
<p>Their use tend to greatly diminish. Among their limitation are a limit
capability to express constraints on the order of tag children, the fact they
the DTD themselves are written in a separate language totally different from
XML, and that users must learn as a result.</p>
</li>
<li><p class="first">XML Schema</p>
<p>The XML schemas are replacing the DTDs. They are written in XML, and provide
an extensive capability to describe what the XML document should look like.
In fact, almost all Ada types can be described in an XML schema, including
range constraints, arrays, records, type inheritance, abstract types,....</p>
<p>It is for instance possible to indicate that the value of a preference, in
our example, must be a string of length 6. Any other length will result in a
validation error.</p>
</li>
</ul>
</div>
<div class="section" id="xml-schema-syntax">
<h2>6.2. XML Schema Syntax<a class="headerlink" href="#xml-schema-syntax" title="Permalink to this headline">¶</a></h2>
<p>The Schema modules provides subprograms and types to parse an XML schema and
validate an XML document with this schema.</p>
<p>This document does not provide a full documentation on the format of XML
Schemas. This is extensive, has several obscure features, which, although
supported by XML/Ada, are of little use in most pratical uses. We refer the
reader to the first part of the XML Schema specification, which is designed as
a tutorial (<a class="reference external" href="http://www.w3.org/TR/xmlschema-0/">http://www.w3.org/TR/xmlschema-0/</a>).</p>
<p>The typical extension for a schema file is <tt class="file docutils literal"><span class="pre">.xsd</span></tt>.</p>
<p>A schema file must be a valid XML file, and thus start with the usual <cite>&lt;?xml
version=&#8221;1.0&#8221; ?&gt;</cite> line. The root node must be named <cite>schema</cite>, and belong to the
namespace (<a class="reference external" href="http://www.w3.org/2001/XMLSchema/">http://www.w3.org/2001/XMLSchema/</a>). The handling of namespaces is fairly
powerful, but also complex. A given XML document might have nodes belonging to
several namespaces, and thus several schema files might have to be loaded, each
defining one of the namespaces.</p>
<p>In the following simple example, we will not define our schema for a specific
namespace, and thus no special attribute is needed for the root node.  Thus,
our document will be organized as:</p>
<div class="highlight-xml"><div class="highlight"><pre><span class="cp">&lt;?xml version=&quot;1.0&quot; ?&gt;</span>
<span class="nt">&lt;xsd:schema</span> <span class="na">xmlns:xsd=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema&quot;</span><span class="nt">&gt;</span>
    ... rest of the description goes here ...
<span class="nt">&lt;/xsd:schema&gt;</span>
</pre></div>
</div>
<p>An XML schema does not enforce a specific root node in the XML documents it
validates. However, it must define all the valid elements that can be used in
the XML file. This is done through the <cite>&lt;element&gt;</cite> tag, which takes
one mandatory attribute, the name of the element we are defining.</p>
<p>The contents of the element is then defined in one of two ways:</p>
<ul>
<li><p class="first">Through a <cite>type</cite> attribute.</p>
<p>Schemas come with a number of predefined simple types. A simple type is
such that an element of that type accepts no child node, and that its
contents must satisfy additional constraints (be an integer, a date,
...).</p>
<p>Among the predefined simple type (which are all defined in the namespace
<a class="reference external" href="http://www.w3.org/2001/XMLSchema/">http://www.w3.org/2001/XMLSchema/</a>),
one can find: <cite>string</cite>, <cite>integer</cite>, <cite>byte</cite>, <cite>date</cite>, <cite>time</cite>, <cite>dateTime</cite>,
<cite>boolean</cite>,...</p>
<p>If no additional constraint should be enforced on this simple type when
applied to the element, the type of the element is given through a <cite>type</cite>
attribute, as in:</p>
<div class="highlight-xml"><div class="highlight"><pre><span class="nt">&lt;xsd:element</span> <span class="na">name=</span><span class="s">&quot;tag1&quot;</span> <span class="na">type=</span><span class="s">&quot;xsd:string&quot;</span>  <span class="nt">/&gt;</span>
<span class="nt">&lt;xsd:element</span> <span class="na">name=</span><span class="s">&quot;tag2&quot;</span> <span class="na">type=</span><span class="s">&quot;xsd:boolean&quot;</span> <span class="nt">/&gt;</span>
</pre></div>
</div>
<p>which would accept the following XML files:</p>
<div class="highlight-xml"><div class="highlight"><pre><span class="nt">&lt;tag1&gt;</span>Any string is valid here<span class="nt">&lt;/tag1&gt;</span>
</pre></div>
</div>
<p>and:</p>
<div class="highlight-xml"><div class="highlight"><pre><span class="nt">&lt;tag2&gt;</span>true<span class="nt">&lt;/tag2&gt;</span>
</pre></div>
</div>
<p>but not:</p>
<div class="highlight-xml"><div class="highlight"><pre><span class="nt">&lt;tag2&gt;</span>String<span class="nt">&lt;/tag2&gt;</span>
</pre></div>
</div>
<p>As will be described later, it is possible to create new types in XML schema,
which are created with a name. Such new types can also be associated with the
element through the <cite>type</cite> attribute.</p>
</li>
<li><p class="first">Through an inline type definition</p>
<p>If the element must accept child elements, or if a further constraint needs
to be enforced on the list of valid values, one must create the type. As
mentioned above, this can be done by creating a type separately and
referencing it by name, or through an inline type definition.</p>
<p>The syntax is mostly the same in both cases. Schemas distinguish between the
notion of simple types (that accept no child element) and complex types (that
accept child elements, and possibly text value).</p>
<p>To define a simple type, based on string, but that only allows a limited set
of value (similar to an Ada enumeration), one would create a restriction of
the standard string type, as in:</p>
<div class="highlight-xml"><div class="highlight"><pre><span class="nt">&lt;xsd:element</span> <span class="na">name=</span><span class="s">&quot;tag3&quot;</span><span class="nt">&gt;</span>
 <span class="nt">&lt;xsd:simpleType&gt;</span>
   <span class="nt">&lt;xsd:restriction</span> <span class="na">base=</span><span class="s">&quot;xsd:string&quot;</span><span class="nt">&gt;</span>
     <span class="nt">&lt;xsd:enumeration</span> <span class="na">value=</span><span class="s">&quot;value1&quot;</span> <span class="nt">/&gt;</span>
     <span class="nt">&lt;xsd:enumeration</span> <span class="na">value=</span><span class="s">&quot;value2&quot;</span> <span class="nt">/&gt;</span>
   <span class="nt">&lt;/xsd:restriction&gt;</span>
 <span class="nt">&lt;/xsd:simpleType&gt;</span>
<span class="nt">&lt;/xsd:element&gt;</span>
</pre></div>
</div>
<p>Similarly, we could create an integer type whose valid range of values
is between 10 and 20, as in:</p>
<div class="highlight-xml"><div class="highlight"><pre><span class="nt">&lt;xsd:element</span> <span class="na">name=</span><span class="s">&quot;tag4&quot;</span><span class="nt">&gt;</span>
 <span class="nt">&lt;xsd:simpleType&gt;</span>
   <span class="nt">&lt;xsd:restriction</span> <span class="na">base=</span><span class="s">&quot;xsd:byte&quot;</span><span class="nt">&gt;</span>
     <span class="nt">&lt;xsd:minInclusive</span> <span class="na">value=</span><span class="s">&quot;10&quot;</span> <span class="nt">/&gt;</span>
     <span class="nt">&lt;xsd:maxInclusive</span> <span class="na">value=</span><span class="s">&quot;20&quot;</span> <span class="nt">/&gt;</span>
   <span class="nt">&lt;/xsd:restriction&gt;</span>
 <span class="nt">&lt;/xsd:simpleType&gt;</span>
<span class="nt">&lt;/xsd:element&gt;</span>
</pre></div>
</div>
<p>Complex types allow elements to have child nodes, as well as attributes. The
list of valid attributes is created by a set of <cite>&lt;xsd:attribute&gt;</cite> tags, and
the list of valid child nodes is generally defined either through a
<cite>&lt;xsd:choice&gt;</cite> or a <cite>&lt;xsd:sequence&gt;</cite> node (although it is possible to
indicate that any child node is authorized, among other things).</p>
<p><cite>&lt;xsd:choice&gt;</cite> indicate the children can appear in any order, whereas
<cite>&lt;xsd:sequence&gt;</cite> enforces a specific order on children.</p>
<p>In both cases, extra attributes can be specified to indicate the number of
times the sequence or choice itself can be repeated, or that each child node
can appear.</p>
<p>For instance, we can indicate that <cite>tag5</cite> accepts between 1 and 4 child
nodes, chosen among <cite>tag6</cite> and <cite>tag7</cite>, but that the latter, if
present, can only appear once. In addition, tag5 accepts one optional
attribute. Note that the type of tag6 and tag7 is here specified through a
<cite>type</cite> attribute, although it could in turn be defined inline:</p>
<div class="highlight-xml"><pre>&lt;xsd:element name="tag5"&gt;
  &lt;xsd:complexType&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="tag6" type="xsd:string"
                   minOccurs="1" maxOccurs="3/&gt;
      &lt;xsd:element name="tag7" type="xsd:string" maxOccurs="1" /&gt;
    &lt;/xsd:choice&gt;
    &lt;xsd:attribute name="attr" type="xsd:boolean" use="optional" /&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:element&gt;</pre>
</div>
<p>In the example above, if <cite>tag6</cite> was defined elsewhere in the
schema, we could use a reference to it, instead of duplicating its
type definition, as in:</p>
<div class="highlight-xml"><div class="highlight"><pre><span class="nt">&lt;xsd:element</span> <span class="na">ref=</span><span class="s">&quot;tag6&quot;</span> <span class="nt">/&gt;</span>
</pre></div>
</div>
<p>If you need an element with no child element (just a string value),
but that accepts attributes, this also must be defined through a
complex type, as in:</p>
<div class="highlight-xml"><div class="highlight"><pre><span class="nt">&lt;xsd:element</span> <span class="na">name=</span><span class="s">&quot;tag8&quot;</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;xsd:complexType&gt;</span>
    <span class="nt">&lt;xsd:simpleContent&gt;</span>
      <span class="nt">&lt;xsd:extension</span> <span class="na">base=</span><span class="s">&quot;xsd:string&quot;</span><span class="nt">&gt;</span>
         <span class="nt">&lt;xsd:attribute</span> <span class="na">name=</span><span class="s">&quot;attr&quot;</span> <span class="na">type=</span><span class="s">&quot;xsd:boolean&quot;</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;/xsd:extension&gt;</span>
    <span class="nt">&lt;/xsd:simpleContent&gt;</span>
  <span class="nt">&lt;/xsd:complexType&gt;</span>
<span class="nt">&lt;/xsd:element&gt;</span>
</pre></div>
</div>
</li>
</ul>
<p>As mentioned before, instead of defining inline types, we could explicitly
declare them, and reference them in the element declaration later on:</p>
<div class="highlight-xml"><div class="highlight"><pre><span class="nt">&lt;xsd:simpleType</span> <span class="na">name=</span><span class="s">&quot;string_of_length_10&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;xsd:restriction</span> <span class="na">base=</span><span class="s">&quot;xsd:string&quot;</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;xsd:length</span> <span class="na">value=</span><span class="s">&quot;10&quot;</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/xsd:restriction&gt;</span>
<span class="nt">&lt;/xsd:simpleType&gt;</span>
<span class="nt">&lt;xsd:element</span> <span class="na">name=</span><span class="s">&quot;tag9&quot;</span> <span class="na">type=</span><span class="s">&quot;string_of_length_10&quot;</span> <span class="nt">/&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="connecting-xml-documents-and-schemas">
<h2>6.3. Connecting XML documents and schemas<a class="headerlink" href="#connecting-xml-documents-and-schemas" title="Permalink to this headline">¶</a></h2>
<p>There are several ways that XML/Ada uses to find what schema to use when
validating a file.</p>
<ul>
<li><p class="first">Manually creating the grammar.</p>
<p>The schema module contains the package <cite>Schema.Validators</cite> which
allows you to create a grammar by hand. It is very low-level, and it is
likely that you will never need to use it. It is used internally mostly,
and when creating the schema which is used to validate schema files
themselves.</p>
</li>
<li><p class="first">Explicitly parsing a schema file</p>
<p>Parsing a schema file can be done through a call to parse for a reader
derived from <cite>Schema.Schema_Readers.Schema_reader</cite>.  As usual, you
call <cite>Parse</cite>, and pass it an input source. As output, you get
access to a grammar, that can then be given to another instance of a
<cite>Schema.Readers.Validating_Reader</cite>.</p>
<p>This technique will generally be used when you need to validate several
XML files with the same grammar: you parse the grammar only once, and
then reuse its instance, instead of reparsing the <tt class="file docutils literal"><span class="pre">.xsd</span></tt> file every
time:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">with</span> <span class="nn">Schema.Schema_Readers</span><span class="p">,</span> <span class="n">Schema</span><span class="p">.</span><span class="n">Validators</span><span class="p">,</span> <span class="n">Input_Sources</span><span class="p">.</span><span class="n">File</span><span class="p">;</span>
<span class="kn">use</span>  <span class="nn">Schema.Schema_Readers</span><span class="p">,</span> <span class="n">Schema</span><span class="p">.</span><span class="n">Validators</span><span class="p">,</span> <span class="n">Input_Sources</span><span class="p">.</span><span class="n">File</span><span class="p">;</span>
<span class="kn">with</span> <span class="nn">Schema.Schema_Grammar</span><span class="p">;</span>  <span class="kn">use</span>  <span class="nn">Schema.Schema_Grammar</span><span class="p">;</span>

<span class="kd">procedure</span> <span class="nf">SchemaExample2</span> <span class="kr">is</span>
   <span class="n">Grammar</span> <span class="p">:</span> <span class="n">XML_Grammar</span><span class="p">;</span>
   <span class="n">Schema</span>  <span class="p">:</span> <span class="n">Schema_Reader</span><span class="p">;</span>
   <span class="n">Read</span>    <span class="p">:</span> <span class="n">File_Input</span><span class="p">;</span>
<span class="kr">begin</span>
     <span class="n">Open</span> <span class="p">(</span><span class="s">&quot;file.xsd&quot;</span><span class="p">,</span> <span class="n">Read</span><span class="p">);</span>
     <span class="n">Parse</span> <span class="p">(</span><span class="n">Schema</span><span class="p">,</span> <span class="n">Read</span><span class="p">);</span>
     <span class="n">Close</span> <span class="p">(</span><span class="n">Read</span><span class="p">);</span>

     <span class="n">Grammar</span> <span class="p">:=</span> <span class="n">Get_Grammar</span> <span class="p">(</span><span class="n">Schema</span><span class="p">);</span>
<span class="kr">end</span> <span class="nf">SchemaExample2</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>In the example above, the schema file itself is validated against the
official schema for schema files.</p>
<p>The resulting grammar object is in fact a collection of parsed schema
files, each associated with its own namespace. It can be kept as long as
you need it in your application. Memory will automatically be reclaimed
when no longer needed.</p>
<p>Every time you parse an XML file later on, you must associated the
Grammar with the parser:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="kr">declare</span>
   <span class="n">Read</span>      <span class="p">:</span> <span class="n">File_Input</span><span class="p">;</span>
   <span class="n">My_Reader</span> <span class="p">:</span> <span class="n">Validating_Reader</span><span class="p">;</span>
<span class="kr">begin</span>
   <span class="n">Set_Grammar</span> <span class="p">(</span><span class="n">My_Reader</span><span class="p">,</span> <span class="n">Grammar</span><span class="p">);</span>
   <span class="n">Set_Feature</span> <span class="p">(</span><span class="n">My_Reader</span><span class="p">,</span> <span class="n">Schema_Validation_Feature</span><span class="p">,</span> <span class="kc">True</span><span class="p">);</span>
   <span class="n">Open</span> <span class="p">(</span><span class="n">Xml_File</span><span class="p">.</span><span class="kr">all</span><span class="p">,</span> <span class="n">Read</span><span class="p">);</span>
   <span class="n">Parse</span> <span class="p">(</span><span class="n">My_Reader</span><span class="p">,</span> <span class="n">Read</span><span class="p">);</span>
   <span class="n">Close</span> <span class="p">(</span><span class="n">Read</span><span class="p">);</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</li>
<li><p class="first">Implicitly parsing the schema</p>
<p>Two special attributes, defined in the Schema standard, can be used to
indicate, in an XML document itself, that it should be validated with
a specific schema.</p>
<p>These attributes are both defined in a special namespace,
<a class="reference external" href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>.</p>
<ul>
<li><p class="first"><cite>xsi:noNamespaceSchemaLocation</cite></p>
<p>The value of this attribute is the name of a file that contains
the schema to use for elements that are not associated with a
specific namespace.</p>
</li>
<li><p class="first"><cite>xsi:schemaLocation</cite></p>
<p>This attribute is a list of strings, alternatively the prefix of
a namespace and the name of an xsd file to use for that
namespace. For instance, <cite>&#8220;ns1 file1.xsd ns2 file2.xsd&#8221;</cite>.</p>
</li>
</ul>
<p>When it encounters any of these two attributes, XML/Ada will
automatically parse the corresponding schema files, and use the result
to validate the file.</p>
</li>
</ul>
</div>
<div class="section" id="validating-documents-with-sax">
<h2>6.4. Validating documents with SAX<a class="headerlink" href="#validating-documents-with-sax" title="Permalink to this headline">¶</a></h2>
<p>XML/Ada is quite unique in the category of XML parsers, since it allows the
validation of XML files when you are using an event-based parser with SAX.
Most other XML parsers only work on DOM trees.</p>
<p>Basing the validation on SAX is more efficient, since there is no need to read
the whole XML stream (or even the grammar) in memory before starting the
validation, and errors can be reported immediatly.</p>
<p>It also requires less memory to run, and thus can validate large XML
documents.</p>
<p>It also means that even if you are using SAX, and not DOM, you still have
access to the validation features.</p>
<p>Validating a XML document while parsing it is basically done the same as when
using SAX itself. Instead of inheriting from <cite>Sax.Readers.Reader</cite>, your tagged
type must inherit from <cite>Schema.Readers.Validating_Reader</cite>.</p>
<p>As usual, you can still override the predefined primitive operations like
<cite>Start_Element</cite>, <cite>End_Element</cite>, ...</p>
<p>Note the activation of the <cite>Schema_Validation_Feature</cite> feature, without which
no validation takes place:</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">with</span> <span class="nn">Sax.Readers</span><span class="p">;</span>        <span class="kn">use</span> <span class="nn">Sax.Readers</span><span class="p">;</span>
<span class="kn">with</span> <span class="nn">Schema.Readers</span><span class="p">;</span>     <span class="kn">use</span> <span class="nn">Schema.Readers</span><span class="p">;</span>
<span class="kn">with</span> <span class="nn">Input_Sources.File</span><span class="p">;</span> <span class="kn">use</span> <span class="nn">Input_Sources.File</span><span class="p">;</span>

<span class="kd">procedure</span> <span class="nf">SchemaExample</span> <span class="kr">is</span>
   <span class="n">Input</span> <span class="p">:</span> <span class="n">File_Input</span><span class="p">;</span>
   <span class="n">My_Reader</span> <span class="p">:</span> <span class="n">Validating_Reader</span><span class="p">;</span>
<span class="kr">begin</span>
   <span class="n">Set_Public_Id</span> <span class="p">(</span><span class="n">Input</span><span class="p">,</span> <span class="s">&quot;Preferences file&quot;</span><span class="p">);</span>
   <span class="n">Open</span> <span class="p">(</span><span class="s">&quot;pref.xml&quot;</span><span class="p">,</span> <span class="n">Input</span><span class="p">);</span>

   <span class="n">Set_Feature</span> <span class="p">(</span><span class="n">My_Reader</span><span class="p">,</span> <span class="n">Schema_Validation_Feature</span><span class="p">,</span> <span class="kc">True</span><span class="p">);</span>
   <span class="n">Parse</span> <span class="p">(</span><span class="n">My_Reader</span><span class="p">,</span> <span class="n">Input</span><span class="p">);</span>

   <span class="n">Close</span> <span class="p">(</span><span class="n">Input</span><span class="p">);</span>
<span class="kr">end</span> <span class="nf">SchemaExample</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="validating-documents-with-dom">
<h2>6.5. Validating documents with DOM<a class="headerlink" href="#validating-documents-with-dom" title="Permalink to this headline">¶</a></h2>
<p>This is very similar to using DOM itself, except the base class of your
reader should be <cite>Schema.Dom_Readers.Tree_Reader</cite>. Going back to the
example described in <a class="reference internal" href="dom.html#using-dom"><em>Using DOM</em></a>, you would use the following to
validate XML streams before generating the DOM tree.</p>
<div class="highlight-ada"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">with</span> <span class="nn">Input_Sources.File</span><span class="p">;</span> <span class="kn">use</span> <span class="nn">Input_Sources.File</span><span class="p">;</span>
<span class="kn">with</span> <span class="nn">Sax.Readers</span><span class="p">;</span>        <span class="kn">use</span> <span class="nn">Sax.Readers</span><span class="p">;</span>
<span class="kn">with</span> <span class="nn">DOM.Core</span><span class="p">;</span>           <span class="kn">use</span> <span class="nn">DOM.Core</span><span class="p">;</span>
<span class="kn">with</span> <span class="nn">Schema.Dom_Readers</span><span class="p">;</span> <span class="kn">use</span> <span class="nn">Schema.Dom_Readers</span><span class="p">;</span>

<span class="kd">procedure</span> <span class="nf">DomSchemaExample</span> <span class="kr">is</span>
   <span class="n">Input</span>  <span class="p">:</span> <span class="n">File_Input</span><span class="p">;</span>
   <span class="n">Reader</span> <span class="p">:</span> <span class="n">Schema</span><span class="p">.</span><span class="n">Dom_Readers</span><span class="p">.</span><span class="n">Tree_Reader</span><span class="p">;</span>
   <span class="n">Doc</span>    <span class="p">:</span> <span class="n">Document</span><span class="p">;</span>
<span class="kr">begin</span>
   <span class="n">Set_Public_Id</span> <span class="p">(</span><span class="n">Input</span><span class="p">,</span> <span class="s">&quot;Preferences file&quot;</span><span class="p">);</span>
   <span class="n">Open</span> <span class="p">(</span><span class="s">&quot;pref.xml&quot;</span><span class="p">,</span> <span class="n">Input</span><span class="p">);</span>

   <span class="n">Set_Feature</span> <span class="p">(</span><span class="n">Reader</span><span class="p">,</span> <span class="n">Validation_Feature</span><span class="p">,</span> <span class="kc">False</span><span class="p">);</span>
   <span class="n">Set_Feature</span> <span class="p">(</span><span class="n">Reader</span><span class="p">,</span> <span class="n">Namespace_Feature</span><span class="p">,</span> <span class="kc">False</span><span class="p">);</span>

   <span class="n">Parse</span> <span class="p">(</span><span class="n">Reader</span><span class="p">,</span> <span class="n">Input</span><span class="p">);</span>
   <span class="n">Close</span> <span class="p">(</span><span class="n">Input</span><span class="p">);</span>

   <span class="n">Doc</span> <span class="p">:=</span> <span class="n">Get_Tree</span> <span class="p">(</span><span class="n">Reader</span><span class="p">);</span> 

   <span class="n">Free</span> <span class="p">(</span><span class="n">Reader</span><span class="p">);</span>
<span class="kr">end</span> <span class="nf">DomSchemaExample</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="unsupported-schema-elements">
<h2>6.6. Unsupported schema elements<a class="headerlink" href="#unsupported-schema-elements" title="Permalink to this headline">¶</a></h2>
<p>Not all aspects of XML schemas are supported by XML/Ada.
In particular, it does not currently support XPath, so any part of the
schema that is related to XPath expressions (for instance <cite>&lt;xsd:key&gt;</cite>
and <cite>&lt;xsd:unique&gt;</cite>) are not supported currently.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="using.html" title="7. Using the library"
             >next</a> |</li>
        <li class="right" >
          <a href="dom.html" title="5. The DOM module"
             >previous</a> |</li>
        <li><a href="index.html">XML/Ada: the XML Library for Ada 4.3w documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2003-2012, AdaCore.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>